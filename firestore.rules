/**
 * This ruleset enforces a strict user-ownership model for the Eternal Echo application.
 * All user-specific data, including proposals and their associated photos, is nested
 * under a user-specific path `/users/{userId}`. This path-based security model ensures
 * that users can only access their own data, providing strong authorization guarantees
 * without the need for costly cross-document lookups.
 *
 * Core Philosophy:
 * Data is either private to a single user or write-only for analytics. There is no
 * concept of shared or public user-generated content in this model.
 *
 * Data Structure:
 * - /users/{userId}/proposals/{proposalId}: Contains the user's proposal details.
 * - /users/{userId}/proposals/{proposalId}/photos/{photoId}: Stores photos for a given proposal.
 * - /decision_history/{decisionHistoryId}: A write-only collection for logging user
 *   interactions for machine learning, accessible even to anonymous users.
 *
 * Key Security Decisions:
 * - Strict Ownership: All CRUD operations within the `/users/{userId}` path are restricted
 *   to the authenticated user whose UID matches `{userId}`.
 * - No User Enumeration: Listing the top-level `/users` collection is explicitly disallowed
 *   to protect user privacy.
 * - Write-Only Analytics: The `/decision_history` collection is configured as a secure
 *   "drop box." Any user (including anonymous ones) can create documents, but no one
 *   can read, update, or delete them via the client SDKs. This is ideal for collecting
 *   training data without exposing it.
 * - Relational Integrity: On document creation, rules validate that IDs within the
 *   document data match the IDs in the document path, ensuring data consistency. These
 *   IDs are immutable on update.
 *
 * Denormalization for Authorization:
 * This ruleset leverages a path-based security structure (`/users/{userId}/...`) as its
 * primary authorization mechanism. This is a form of denormalization where the ownership
 * information (`userId`) is encoded in the document's path. This allows for simple,
 * fast, and highly secure rules like `isOwner(userId)` without needing `get()` calls to
 * check ownership on related documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    /**
     * Verifies if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Verifies if the requesting user's UID matches the specified userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
    * Verifies ownership for an existing document. Used for update and delete
    * operations to ensure the target document exists before modification.
    */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On create, validates that the proposal document's internal `id` field
     * matches the document ID from the path.
     */
    function isProposalDataValidForCreate(proposalId) {
      let data = request.resource.data;
      return data.id == proposalId;
    }

    /**
     * On update, ensures the proposal's `id` field remains unchanged.
     */
    function isProposalDataValidForUpdate() {
      let data = request.resource.data;
      return data.id == resource.data.id;
    }
    
    /**
     * On create, validates that the photo document's internal `id` and `proposalId`
     * fields match the document IDs from the path.
     */
    function isPhotoDataValidForCreate(proposalId, photoId) {
      let data = request.resource.data;
      return data.id == photoId && data.proposalId == proposalId;
    }

    /**
     * On update, ensures the photo's `id` and `proposalId` fields remain unchanged.
     */
    function isPhotoDataValidForUpdate() {
      let data = request.resource.data;
      return data.id == resource.data.id && data.proposalId == resource.data.proposalId;
    }

    /**
     * @description Rules for the user-specific data tree. This path itself does not
     *              represent a document but serves as a parent for all user-owned collections.
     * @path        /users/{userId}
     * @allow       A user (uid: 'user_abc') can (get, list, create, update, delete) documents in subcollections like `proposals`.
     * @deny        An anonymous user or a different user (uid: 'user_xyz') attempting to access anything under `/users/user_abc`.
     * @deny        Any user attempting to `list` the top-level `/users` collection.
     * @principle   Establishes a secure root path for all user-owned data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;

      /**
       * @description Secures proposal documents, ensuring only the owner can manage them.
       * @path        /users/{userId}/proposals/{proposalId}
       * @allow       A user (uid: 'user_abc') can (create) a new proposal at `/users/user_abc/proposals/prop_123`.
       * @allow       The same user can (get), (list), (update), or (delete) their own proposals.
       * @deny        A different user (uid: 'user_xyz') attempting to (get) `/users/user_abc/proposals/prop_123`.
       * @deny        A user trying to (create) a proposal where the `id` in the data does not match `{proposalId}`.
       * @principle   Enforces document ownership for all operations and validates relational integrity on writes.
       */
      match /proposals/{proposalId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isProposalDataValidForCreate(proposalId);
        allow update: if isExistingOwner(userId) && isProposalDataValidForUpdate();
        allow delete: if isExistingOwner(userId);

        /**
         * @description Secures photo subcollections, inheriting ownership from the parent proposal and user.
         * @path        /users/{userId}/proposals/{proposalId}/photos/{photoId}
         * @allow       A user (uid: 'user_abc') can (create) a new photo in their own proposal subcollection.
         * @allow       The same user can (get), (list), (update), or (delete) their own photos.
         * @deny        A different user (uid: 'user_xyz') attempting to (list) photos under `/users/user_abc/...`.
         * @deny        A user trying to (create) a photo where the `proposalId` in the data does not match the `{proposalId}` in the path.
         * @principle   Enforces inherited ownership from the path and validates relational integrity.
         */
        match /photos/{photoId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId) && isPhotoDataValidForCreate(proposalId, photoId);
          allow update: if isExistingOwner(userId) && isPhotoDataValidForUpdate();
          allow delete: if isExistingOwner(userId);
        }
      }
    }
    
    /**
     * @description Secures the decision history collection used for machine learning.
     *              This collection acts as a "write-only" log or "drop box".
     * @path        /decision_history/{decisionHistoryId}
     * @allow       Any user, including anonymous ones, can (create) a new decision record.
     * @deny        Any user attempting to (get), (list), (update), or (delete) any record.
     * @principle   Allows for public data submission while preventing data leakage by disallowing all read and modification operations from the client.
     */
    match /decision_history/{decisionHistoryId} {
      allow get: if false;
      allow list: if false;
      allow create: if true;
      allow update: if false;
      allow delete: if false;
    }
  }
}